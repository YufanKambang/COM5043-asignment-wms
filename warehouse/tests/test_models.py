"""This is to testing the functionality at  warehouse/models.py"""


import pytest

from unittest.mock import Mock
from warehouse.models import Product, Supplier, CustomerOrder

@pytest.mark.django_db #wraps my test in a database transaction, which it will roll back after the test finishes
@pytest.mark.parametrize("model_class, create_kwargs, expected_result", [
    (Product, {"id": 123, "name": "test_product", "description": "it is a test", "stock_quantity": 69, "restock_indicator": 13, "cost_price": 13.69, "selling_price": 27.38}, 123),
    (Supplier, {"id": 456, "name": "test_supplier", "contact_email": "test_supplier@mail.com", "phone": "123", "address": "Atlantis"}, 456),
    (CustomerOrder, {"id": 789, "customer_name": "test_customer", "customer_email": "test_customer@mail.com"}, 789),
]) #this is test data that the test function below will itterate through testing each one
def test_model_create(model_class, create_kwargs, expected_result):
    #need to test the creation of an object from each class that does not need a foriegn key
    obj = model_class.objects.create(**create_kwargs)
    
    # this assert uses the .id to get the object id value
    # this value is autogenerated, which may be better than self defining but for the test it is really helpful
    # as all the ibjects will have an id field, due to inheritance from django.db.models.Model  
    assert obj.id == expected_result

@pytest.mark.django_db
def test_product_is_low_stock():
    product = Product.objects.create(
        name="Widget", stock_quantity=2, restock_indicator=5,
        cost_price=3.00, selling_price=5.00
    )
    assert product.is_low_stock() is True

    product.stock_quantity = 6
    product.save()
    assert product.is_low_stock() is False